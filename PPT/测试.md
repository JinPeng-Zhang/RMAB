## 测试各模块功能实现

- [x] WITTLE_INDEX_CLASS.PY
  - [x] wittle_index
  - [x] W_fair_drop
  - [x] MDP
  - [x] burst(v1~v4)
  - [x] performance
- [x] configure API.py
  - [x] CONFIGURE
- [x] simulation_zip.py
  - [x] queue_simulation



## 联调

- [x] SP+burst_v1+数据采集+经验池收集
- [x] MAX_QUEUE_LEN+burst_v1+数据采集+经验池收集+WITTLE计算+WITTLE配置
- [x] SP+burst_v2+数据采集+经验池收集+WITTLE计算+WITTLE配置
- [x] MAX_QUEUE_LEN+burst_v2+数据采集+经验池收集+WITTLE计算+WITTLE配置
- [x] SP+burst_v3+数据采集+经验池收集+WITTLE计算+WITTLE配置
- [x] MAX_QUEUE_LEN+burst_v3+数据采集+经验池收集+WITTLE计算+WITTLE配置
- [x] SP+burst_v4+数据采集+经验池收集+WITTLE计算+WITTLE配置
- [x] MAX_QUEUE_LEN+burst_v4+数据采集+经验池收集+WITTLE计算+WITTLE配置
- [x] WITTLE+burst_v4+数据采集+经验池收集+WITTLE计算+WITTLE配置
- [x] WITTLE+burst_v4+数据采集+经验池收集+WITTLE计算+WITTLE配置+长时间（来包率变化）

## 联调测试过程出现的问题

1. WITTLE计算过程出现不收敛的情况，一直无法满足接受条件
   1. 不收敛的情况有两种，一个是每更新一次WITTLE，Q值也更新一次，此时对应WITTLE的Q值还没收敛，造成WITTLE和Q最后在小范围内稳定震荡。但是增加Q更新的频率后，发现该情况虽然减少很多，但还是存在。最终WITTLE在小范围内跳动，无法满足结束条件（前后变化值小于0.001），对此忽略该小范围值带来的影响，设置迭代最大次数。
   2. 如想要彻底解决该情况，可以参考QWIC算法的WITTLE计算方式，现根据其范围离散化，后学习出最优的离散值
2. 队列总是无法达到某公平性范围的状态，因而没有样本计算WITTLE
   1. 测试不同的来包率和突发情况，只要样本多，总会出现
   2. 同时对于未出现的状态，对应转移矩阵所在行不使用默认值，改行采用上次转移矩阵的值P' = P_old[row]，其他行对应更新P'[row] = 0.8*P_old[row]+0.2P_new[row]
   3. 若样本无法满足统计需要，可以根据其他状态转移的概率计算未出现状态的转移概率
3. WITTLE结果随着队列长度先增后减
   1. 这个和之前建模情况问题一致，在丢包加入惩罚后能够解决，但同时可能会增大状态空间，qlen尺度上引入丢包状态，[空队列,qlen,丢包]，但是比较WITTLE只根据QLEN

## 性能测试

- [ ] WITTLE+burst_v4+数据采集+经验池收集+WITTLE计算+WITTLE配置+长时间（来包率变化）
- [ ] SP+burst_v4+数据采集+经验池收集+WITTLE计算+WITTLE配置+长时间（来包率变化）
- [ ] 新增调度算法+burst_v4+数据采集+经验池收集+WITTLE计算+WITTLE配置+长时间（来包率变化）

### 性能指标

ECN标记率

丢包率

不同优先级平均队列长度

#### 统计区间

全部仿真时间

#### 参数设计

默认突发流量占端口带宽的2%，公平性指标0.8

设置占比从2%->20%，每次增加1%

公平性指标从0.8->0.1，每次减少0.1



