### 配置文件

仿真平台中多个模块类所包含的变量、函数，初始化时所需要的信息有很多重复内容，例如队列离散化长度、状态空间大小、经验池大小等，因此使用配置文件同意进行初始化设置，防止遗漏某一个而导致冲突问题。

```json
sim_dict = {
    'queue_size': 20,
    'u_unit' : 0.05,
    'pool_size': 320000,
    'total_time' : 100010,
    'wittle_update_cycle' : 100000,
    'pcome' : [0.02534504,0.13369194,0.09386043,0.01754024,0.17004173,0.2459021,0.03012342,0.0451653 ],
    'bstart_tim' : [100],
    'Scheduling_algorithm' : "MAX_QUEUE_LEN",
    'Congestion_handling' : 'FULL_DROP',
    'burst_version':'v1',
    'wf':0.8
}

```

#### 可读性

配置文件json多行保存

```python
with open("./TEST/simulation_v2_2.json", "w", encoding='utf-8') as f:
    sim_json = json.dump(sim_dict,f,indent=2, sort_keys=True, ensure_ascii=False)
```



### 调度器分析

原先调度模式循环周期为1ms,采取的为单循环单队列的调度模式，当调度队列数据包数量k<1时，该循环只发送该队列的k个数据包，即使其他队列有数据包也不发送，导致最多每循环浪费了1-k的带宽

单循环多队列的方式，每个循环，当发送数据量不足1时，继续根据算法调度其他队列数据包发送，直至带宽完全使用或端口为空。

```
v2.0
 def outpacket(self,times):
        '''
        返回选择的一个发包队列
        '''
        num = -1
        q = -1
        if self.Scheduling_algorithm == "SP":
            q,num = self.Strict_priority_algorithm()
        elif self.Scheduling_algorithm == "WITTLE":
            q,num = self.WITTLE_algorithm()
        elif self.Scheduling_algorithm == "MAX_QUEUE_LEN":
            q,num = self.MAX_QUEUE_LEN_algorithm()
        if num>0:
            self.queue[q] = self.queue[q]-num
            self.action_Collect(times,q)
        if self.print_log:
            if num >0:
                self.log("time:{} send queue{} {} packets".format(times,q,num))
            elif num == 0:
                self.log("time:{} queues if empty".format(times))
            else:
                self.log("Scheduling_algorithm name {} is error".format(self.Scheduling_algorithm))
```

改为单循环多队列方式会引入新的问题：

原模型的动作空间由原来的0，1转化为新的[0,1]连续范围，这与WITTLE INDEX建模矛盾

#### 严格优先级SP调度

为了保证带宽，队列状态采取向下取整的方式

```
def Strict_priority_algorithm(self):
    q = 0
    for _q in range(self.priority):
        if self.queue[_q]>1:
            return _q,1
    return q,self.queue[q]
```

改为四舍五入取整

```
def Strict_priority_algorithm(self):
    q = 0
    for _q in range(self.priority):
        if self.queue[_q]>0.5:
            return _q,min(self.queue[_q],1)
    return q,self.queue[q]
```

### WITTLE调度

默认状态为整数形式的队列长度（❌）

```
def WITTLE_algorithm(self):
    WI = self.WITTLE[0][self.queue[0]]
    q = 0
    for _q in range(self.priority-1):
        if self.WITTLE[_q+1][self.queue[_q+1]]>WI:
            WI = self.WITTLE[_q+1][self.queue[_q+1]]
            q = _q+1
    if self.queue[q]>1:
        return q,1
    return q,self.queue[q]
```

改为，计算各队列状态值

```
def WITTLE_algorithm(self):
    WI = self.WITTLE[0][self.EXP_cache['q0'][0]]
    q = 0
    for _q in range(self.priority-1):
        if self.WITTLE[_q+1][self.EXP_cache[f'q{_q+1}'][0]]>WI:
            WI = self.WITTLE[_q+1][self.EXP_cache[f'q{_q+1}'][0]]
            q = _q+1
    return q,min(self.queue[q],1)
```



### 状态收集

采用的是向下取整的方式

```
def state_Collect(self,times):
    data = {'TIME':times,'TYPE':'S','DATA':[]}
    for q in range(self.priority):
        QLEN = int(self.queue[q])
        U = np.sum(self.queue[0:q])/np.sum(self.queue)
        U = round(U/self.u_unit)
        S = QLEN*21+U
        data['DATA'].append(S)
    self.EXP_Collect(data)
```

改为四舍五入

```
    QLEN = round(self.queue[q])	
```

### 状态转换

状态值转化为[qlen,u]

```python
v2.0错误逻辑
def s_to_u_qlen(self,s):
    qlen = int(s/(self.qlen_size+1))
    u = (s%(self.qlen_size+1))*self.u_unit
    return u,qlen
```

修正后

```python
 def s_to_u_qlen(self,s):
        fair = 1+1/self.u_unit
        qlen = int(s/fair)
        u = (s%fair)*self.u_unit
        return u,qlen
```

[qlen,u]转化为状态值

```
def state_Collect(self,times):
    data = {'TIME':times,'TYPE':'S','DATA':[]}
    for q in range(self.priority):
        QLEN = round(self.queue[q])
        U = np.sum(self.queue[0:q])/np.sum(self.queue)
        U = round(U/self.u_unit)
        S = QLEN*int(1+1/self.u_unit)+U
        data['DATA'].append(S)
    self.EXP_Collect(data)
```

