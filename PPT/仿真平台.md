### 配置文件

仿真平台中多个模块类所包含的变量、函数，初始化时所需要的信息有很多重复内容，例如队列离散化长度、状态空间大小、经验池大小等，因此使用配置文件同意进行初始化设置，防止遗漏某一个而导致冲突问题。

```json
sim_dict = {
    'queue_size': 20,
    'u_unit' : 0.05,
    'pool_size': 320000,
    'total_time' : 100010,
    'wittle_update_cycle' : 100000,
    'pcome' : [0.02534504,0.13369194,0.09386043,0.01754024,0.17004173,0.2459021,0.03012342,0.0451653 ],
    'bstart_tim' : [100],
    'Scheduling_algorithm' : "MAX_QUEUE_LEN",
    'Congestion_handling' : 'FULL_DROP',
    'burst_version':'v1',
    'wf':0.8
}

```

#### 可读性

配置文件json多行保存

```python
with open("./TEST/simulation_v2_2.json", "w", encoding='utf-8') as f:
    sim_json = json.dump(sim_dict,f,indent=2, sort_keys=True, ensure_ascii=False)
```



### 调度器分析

原先调度模式循环周期为1ms,采取的为单循环单队列的调度模式，当调度队列数据包数量k<1时，该循环只发送该队列的k个数据包，即使其他队列有数据包也不发送，导致最多每循环浪费了1-k的带宽

单循环多队列的方式，每个循环，当发送数据量不足1时，继续根据算法调度其他队列数据包发送，直至带宽完全使用或端口为空。

```
v2.0
 def outpacket(self,times):
        '''
        返回选择的一个发包队列
        '''
        num = -1
        q = -1
        if self.Scheduling_algorithm == "SP":
            q,num = self.Strict_priority_algorithm()
        elif self.Scheduling_algorithm == "WITTLE":
            q,num = self.WITTLE_algorithm()
        elif self.Scheduling_algorithm == "MAX_QUEUE_LEN":
            q,num = self.MAX_QUEUE_LEN_algorithm()
        if num>0:
            self.queue[q] = self.queue[q]-num
            self.action_Collect(times,q)
        if self.print_log:
            if num >0:
                self.log("time:{} send queue{} {} packets".format(times,q,num))
            elif num == 0:
                self.log("time:{} queues if empty".format(times))
            else:
                self.log("Scheduling_algorithm name {} is error".format(self.Scheduling_algorithm))
```

改为单循环多队列方式会引入新的问题：

原模型的动作空间由原来的0，1转化为新的[0,1]连续范围，这与WITTLE INDEX建模矛盾

#### 严格优先级SP调度

为了保证带宽，队列状态采取向下取整的方式

```
def Strict_priority_algorithm(self):
    q = 0
    for _q in range(self.priority):
        if self.queue[_q]>1:
            return _q,1
    return q,self.queue[q]
```

改为四舍五入取整

```
def Strict_priority_algorithm(self):
    q = 0
    for _q in range(self.priority):
        if self.queue[_q]>0.5:
            return _q,min(self.queue[_q],1)
    return q,self.queue[q]
```

### WITTLE调度

默认状态为整数形式的队列长度（❌）

```
def WITTLE_algorithm(self):
    WI = self.WITTLE[0][self.queue[0]]
    q = 0
    for _q in range(self.priority-1):
        if self.WITTLE[_q+1][self.queue[_q+1]]>WI:
            WI = self.WITTLE[_q+1][self.queue[_q+1]]
            q = _q+1
    if self.queue[q]>1:
        return q,1
    return q,self.queue[q]
```

改为，计算各队列状态值

```
def WITTLE_algorithm(self):
    WI = self.WITTLE[0][self.EXP_cache['q0'][0]]
    q = 0
    for _q in range(self.priority-1):
        if self.WITTLE[_q+1][self.EXP_cache[f'q{_q+1}'][0]]>WI:
            WI = self.WITTLE[_q+1][self.EXP_cache[f'q{_q+1}'][0]]
            q = _q+1
    return q,min(self.queue[q],1)
```



### 状态收集

采用的是向下取整的方式

```
def state_Collect(self,times):
    data = {'TIME':times,'TYPE':'S','DATA':[]}
    for q in range(self.priority):
        QLEN = int(self.queue[q])
        U = np.sum(self.queue[0:q])/np.sum(self.queue)
        U = round(U/self.u_unit)
        S = QLEN*21+U
        data['DATA'].append(S)
    self.EXP_Collect(data)
```

改为四舍五入

```
    QLEN = round(self.queue[q])	
```

### 状态转换

状态值转化为[qlen,u]

```python
v2.0错误逻辑
def s_to_u_qlen(self,s):
    qlen = int(s/(self.qlen_size+1))
    u = (s%(self.qlen_size+1))*self.u_unit
    return u,qlen
```

修正后

```python
 def s_to_u_qlen(self,s):
        fair = 1+1/self.u_unit
        qlen = int(s/fair)
        u = (s%fair)*self.u_unit
        return u,qlen
```

[qlen,u]转化为状态值

```
def state_Collect(self,times):
    data = {'TIME':times,'TYPE':'S','DATA':[]}
    for q in range(self.priority):
        QLEN = round(self.queue[q])
        U = np.sum(self.queue[0:q])/np.sum(self.queue)
        U = round(U/self.u_unit)
        S = QLEN*int(1+1/self.u_unit)+U
        data['DATA'].append(S)
    self.EXP_Collect(data)
```

### 突发

v2.0平台已经实现四个版本的突发设置

| 版本 | 说明                                     |
| ---- | :--------------------------------------- |
| V1   | 固定模式                                 |
| V2   | 自定义起始时间和队列，平均突发           |
| V3   | 自定义起始时间和队列，自定义队列突发速率 |
| V4   | v1,v2.v3混合模式                         |

```
v1:busrt = [time1,time2,...,timen]
v2:busrt = {'len':n,'b':[[start_time,end_time,q1_index,q2_index,.....,qk_index],...,[]]}
v3:busrt = {'len':n,'b':[{'start_time':100,'end_time':150,'q1':add_rate,'q2':add_rate,.....,'q2':add_rate},...,{}]}
v4:busrt = {'len':n,'b':[{'type':'v3','data':{'start_time':100,'end_time':150,'q1':add_rate,'q2':add_rate,.....,'q2':add_rate}},{'type':'v2','data':[start_time,end_time,q1_index,q2_index,.....,qk_index]},{'type':'v1','data':200}]}
```

突发固定模式：

```
# simulation时间单位为ms
# 队列容量为10MB（参照华为虚拟队列大小），最大容量（状态）单位20，因此一个状态对应500KB
#端口处理速度为每ms一个容量单位，即500KB/MS，4Gbps
#8个队列单位时间来包速率(无突发)小于4Gbps
#突发时，设置突发场景为来报速率增加6Gbps，持续100ms
#100ms会累积大约150容量单位的数据包，8各队列总容量大小为160，两个比较接近。当调度算法性能差时，很容易出现队列满丢包情况
```

