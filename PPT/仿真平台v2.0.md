### 仿真平台实现框架参照：“ECN-WI - 副本.pptx”中“整体框架“框架图

### 框架内容

```json
queue_simulation{
	priority_queue{
		Priority_NUM:8
		QUEUE:LIST[20]
		queue_siez:20
		Congestion_handling:["ECN","AQM","FULL_DROP"]
		Arrival_probability:LIST[8]
		....
	}
	state_Collect:FUCTION()
	Scheduling_algorithm:["SP","WITTLE","MAX_QUEUE_LEN"]
}


```

```json
configure API{
	Experience_upload:FUCTION()
	WITTLE_UPDATE:FUCTION()
}
```

```json
experience_pool
DIR = ./EXP_POOL
PORT_1(
	q0(
        exp1.txt
        exp2.txt
        ...
        expk.txt
        cong.txt
    )
	q1
	...
	q7
)
PORT_2(
	q0
	q1
	...
	q7
)
...
PORT_n(
	q0
	q1
	...
	q7
)
```



```
WITTLE_INDEX_MODEL{
	calculate_WITTLE:FUCTION()
	W_fair_drop:CLASS()
	MDP:CLASS
}
```



### 功能内容

```
wittle_index
    calculate_WITTLE：根据转移矩阵和奖励矩阵计算WITTLE INDEX
W_fair_drop
	ECN_mark:归一化ECN标记期望
	fair:公平性量化函数
	Wreward:加权REWARD
MDP
	s_to_u_qlen:将状态转化为[公平性，队列长度],暂未使用
	file_exp_to_ptran:读取经验池，计算转移概率
	Reward_matrix:计算奖励矩阵
CONFIGURE
	Experience_upload:将端口收集的经验上传
	WITTLE_UPDATE：将计算的WITTLE下放到端口比较器
 	Experience_create：经验池初始化
    registration：端口注册
queue_simulation
    inpacket:队列来包模拟
        ECN_handle：ECN队列处理
        AQM_handle：AQM队列
        DROP_handle：队列满丢包处理
    outpacket：调度模拟
    	Strict_priority_algorithm：严格优先级调度
    	WITTLE_algorithm：WITTLE调度
    	MAX_QUEUE_LEN_algorithm：最长队列调度
	burst_in：突发来包率
	run：单位时间运行
	state_Collect：状态收集
	action_Collect：动作收集
	EXP_Collect：经验收集
	performance_update：性能统计
	log：日志输出
```

### 环境依赖

os

python3.10.9

numpy1.23.5

### 流量突发

| 版本 | 说明                                     |
| ---- | :--------------------------------------- |
| V1   | 固定模式                                 |
| V2   | 自定义起始时间和队列，平均突发           |
| V3   | 自定义起始时间和队列，自定义队列突发速率 |
| V4   | v1,v2.v3混合模式                         |

### 经验上传

经验池基于文件系统进行内容的存储，包括新经验的加入和旧经验的删除，因此在每次上传经验时，配置API会对需要加入的数量和需要删除的数量进行计算。并合并新经验和未被删除的经验，重新写如经验池。因此在每次上传时都存在大量内容的转移和拷贝。

在这种存储模式下，不适合每采集到一个新的经验便上传。因此在端口的经验收集出建立了一个小型的缓存区，每当储存一定数量的经验后便上传。数量大小设置在仿真器EXP_Collect函数最后。使用标识符*UP_LOAD* 标记储存数量是否满足上传大小。

经验池大小为单个队列320000

当模拟运行时，每次上传需要对端口整个经验池进行读取删除，这导致当经验池不断增大直至上线，这个过程中，文件读取时间占仿真时间比重越来越大，后续严重影响仿真过程。对此将经验池设计进行调整。

边照星：

将每个队列大的经验池差分为多个大小相同（等于端口处小型的缓存区的大小）的小经验池，每次添加和删除最多读取内容为两个子文件，而非整个大文件。

### WITTLE INDEX更新

WITTLE更新逻辑在online.py文件实现，*wittle_update_cycle* 变量指示运行对应ms后计算并更新一次端口的WITTLE值，主要是依靠MDP_MODEL（数据处理模块）计算出队列的转移矩阵，再使用WITTLE_MODEL（WITTLE计算模块）计算出WITTLE INDEX，并下放到对应端口队列的WITTLE缓存区，更新一个端口后打印显示。

### 仿真运行逻辑

仿真所需的各个功能通过模块化进行实现，在运行仿真时运行逻辑实现的online.py文件内

1. 观察时间T,采集样本到MDP_MODEL的经验 POOL中
2. 周期性▲t(建议5min)采集样本，并使用MDP_MODEL的exp_to_ptran计算PTRAN(转移概率矩阵)
3. 创建数组R0 R1,对应动作0 1,循环状态空间vs,使用MDP_MODEL的函数s_to_u_qlen将状态空间映射的公平性参数u和队列长度qlen
4. 根据公平性参数u和队列长度qlen，使用REWARD_MODEL的Wreward函数计算出RO R1
5. 得到RO R1 PTRAN(转移概率矩阵)后，调用WITTLE_MODEL计算出WITTLE值
6.  循环步骤2-5

```python
#2-5
for tim in range(total_time):
    print(tim)
    simulation.run(tim)
    if simulation.UP_LOAD== True:
        configure.Experience_upload(simulation.port_index)
        simulation.EXP_Clear()
    if tim !=0 and tim%wittle_update_cycle==0:
        for q in range(simulation.priority):
            MDP_MODEL.file_exp_to_ptran(simulation.port_index,q)
            WITTLE_MODEL.calculate_WITTLE(R1=MDP_MODEL.R[1],                            \                                                  R0=MDP_MODEL.R[0],ptran=MDP_MODEL.ptran)
            configure.WITTLE_UPDATE(WITTLE_MODEL.WI,simulation.port_index,q)
            print(simulation.WITTLE[q])
```



### 配置文件

仿真平台中多个模块类所包含的变量、函数，初始化时所需要的信息有很多重复内容，例如队列离散化长度、状态空间大小、经验池大小等，因此使用配置文件同意进行初始化设置，防止遗漏某一个而导致冲突问题。

```json
sim_dict = {
    'queue_size': 20,
    'u_unit' : 0.05,
    'pool_size': 320000,
    'total_time' : 100010,
    'wittle_update_cycle' : 100000,
    'pcome' : [0.02534504,0.13369194,0.09386043,0.01754024,0.17004173,0.2459021,0.03012342,0.0451653 ],
    'bstart_tim' : [100],
    'Scheduling_algorithm' : "MAX_QUEUE_LEN",
    'Congestion_handling' : 'FULL_DROP',
    'burst_version':'v1'
}

```

使用dict字典类型储存数据，修改变量的value后并将其保存为不同的json文件，在模拟时读取所需要的json文件



### 性能统计

统计三种算法性能：

- ECN标记率

- 丢包率

- 不同优先级平均队列长度

采用长时间平均

```python
 def performance_update(self,drop,ecn,q):
        '''
        {'len':0,'drop':0,'ecn':0,'time':0}
        '''
        if  self.performance_update_flag:

            drops = self.performance[f'q{q}']['drop']
            ecns = self.performance[f'q{q}']['ecn']
            times = self.performance[f'q{q}']['time']
            lens = self.performance[f'q{q}']['len']
            self.performance[f'q{q}']['drop'] = (drops*times+drop)/(times+1)
            self.performance[f'q{q}']['ecn'] = (ecns*times+ecn)/(times+1)
            self.performance[f'q{q}']['len'] = (lens*times+self.queue[q])/(times+1)
            self.performance[f'q{q}']['time'] = times +1
```

统计次数time

更新算法
$$
data  <--  (data*time+new_data)/(time+1)
$$

$$
time  <--  time+1
$$



### 后续改进

现在的调度器在每个循环(1ms)只能选择固定的队列进行数据包发送，但多数不拥塞的情况，队列长度都小于1，这使得每次调度（1ms），即使其他队列有数据包，也并没有完全发送数量为1（500KB）的数据，这种调度方式是为了符合模型离散化建模。

- 后续改进可能引入单循环多队列的调度模式，使其更符合真实设备。
- 除了SP调度方式以外，还可能引入公平带宽调度方式，提前为每一个队列分配一定的带宽比例
- 线程分离，目前‘’更新逻辑‘（计算WITTLE）和’‘控制路径’（收法包）使用一套线程计算并处理，应该分离成两个线程处理
- OVS部署，将算法引入真实的软件交换机

### 稳定版本

https://github.com/JinPeng-Zhang/RMAB/releases/tag/v2.0

- 功能模块实现
- 联调前两阶段
